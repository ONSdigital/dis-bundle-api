// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package eventsmocks

import (
	"context"
	"github.com/ONSdigital/dis-bundle-api/events"
	"github.com/ONSdigital/dis-bundle-api/models"
	"net/http"
	"sync"
)

// Ensure, that BundleEventsManagerMock does implement events.BundleEventsManager.
// If this is not the case, regenerate this file with moq.
var _ events.BundleEventsManager = &BundleEventsManagerMock{}

// BundleEventsManagerMock is a mock implementation of events.BundleEventsManager.
//
//	func TestSomethingThatUsesBundleEventsManager(t *testing.T) {
//
//		// make and configure a mocked events.BundleEventsManager
//		mockedBundleEventsManager := &BundleEventsManagerMock{
//			CreateBundleUpdatedEventFunc: func(ctx context.Context, r *http.Request, bundle *models.Bundle) *models.Error {
//				panic("mock out the CreateBundleUpdatedEvent method")
//			},
//			CreateContentItemAddedEventFunc: func(ctx context.Context, r *http.Request, contentItem *models.ContentItem) *models.Error {
//				panic("mock out the CreateContentItemAddedEvent method")
//			},
//			CreateContentItemUpdatedEventFunc: func(ctx context.Context, r *http.Request, contentItem *models.ContentItem) *models.Error {
//				panic("mock out the CreateContentItemUpdatedEvent method")
//			},
//		}
//
//		// use mockedBundleEventsManager in code that requires events.BundleEventsManager
//		// and then make assertions.
//
//	}
type BundleEventsManagerMock struct {
	// CreateBundleUpdatedEventFunc mocks the CreateBundleUpdatedEvent method.
	CreateBundleUpdatedEventFunc func(ctx context.Context, r *http.Request, bundle *models.Bundle) *models.Error

	// CreateContentItemAddedEventFunc mocks the CreateContentItemAddedEvent method.
	CreateContentItemAddedEventFunc func(ctx context.Context, r *http.Request, contentItem *models.ContentItem) *models.Error

	// CreateContentItemUpdatedEventFunc mocks the CreateContentItemUpdatedEvent method.
	CreateContentItemUpdatedEventFunc func(ctx context.Context, r *http.Request, contentItem *models.ContentItem) *models.Error

	// calls tracks calls to the methods.
	calls struct {
		// CreateBundleUpdatedEvent holds details about calls to the CreateBundleUpdatedEvent method.
		CreateBundleUpdatedEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R *http.Request
			// Bundle is the bundle argument value.
			Bundle *models.Bundle
		}
		// CreateContentItemAddedEvent holds details about calls to the CreateContentItemAddedEvent method.
		CreateContentItemAddedEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R *http.Request
			// ContentItem is the contentItem argument value.
			ContentItem *models.ContentItem
		}
		// CreateContentItemUpdatedEvent holds details about calls to the CreateContentItemUpdatedEvent method.
		CreateContentItemUpdatedEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R *http.Request
			// ContentItem is the contentItem argument value.
			ContentItem *models.ContentItem
		}
	}
	lockCreateBundleUpdatedEvent      sync.RWMutex
	lockCreateContentItemAddedEvent   sync.RWMutex
	lockCreateContentItemUpdatedEvent sync.RWMutex
}

// InsertBundleUpdatedEvent calls CreateBundleUpdatedEventFunc.
func (mock *BundleEventsManagerMock) InsertBundleUpdatedEvent(ctx context.Context, r *http.Request, bundle *models.Bundle) *models.Error {
	if mock.CreateBundleUpdatedEventFunc == nil {
		panic("BundleEventsManagerMock.CreateBundleUpdatedEventFunc: method is nil but BundleEventsManager.CreateBundleUpdatedEvent was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		R      *http.Request
		Bundle *models.Bundle
	}{
		Ctx:    ctx,
		R:      r,
		Bundle: bundle,
	}
	mock.lockCreateBundleUpdatedEvent.Lock()
	mock.calls.CreateBundleUpdatedEvent = append(mock.calls.CreateBundleUpdatedEvent, callInfo)
	mock.lockCreateBundleUpdatedEvent.Unlock()
	return mock.CreateBundleUpdatedEventFunc(ctx, r, bundle)
}

// CreateBundleUpdatedEventCalls gets all the calls that were made to CreateBundleUpdatedEvent.
// Check the length with:
//
//	len(mockedBundleEventsManager.CreateBundleUpdatedEventCalls())
func (mock *BundleEventsManagerMock) CreateBundleUpdatedEventCalls() []struct {
	Ctx    context.Context
	R      *http.Request
	Bundle *models.Bundle
} {
	var calls []struct {
		Ctx    context.Context
		R      *http.Request
		Bundle *models.Bundle
	}
	mock.lockCreateBundleUpdatedEvent.RLock()
	calls = mock.calls.CreateBundleUpdatedEvent
	mock.lockCreateBundleUpdatedEvent.RUnlock()
	return calls
}

// InsertContentItemAddedEvent calls CreateContentItemAddedEventFunc.
func (mock *BundleEventsManagerMock) InsertContentItemAddedEvent(ctx context.Context, r *http.Request, contentItem *models.ContentItem) *models.Error {
	if mock.CreateContentItemAddedEventFunc == nil {
		panic("BundleEventsManagerMock.CreateContentItemAddedEventFunc: method is nil but BundleEventsManager.CreateContentItemAddedEvent was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		R           *http.Request
		ContentItem *models.ContentItem
	}{
		Ctx:         ctx,
		R:           r,
		ContentItem: contentItem,
	}
	mock.lockCreateContentItemAddedEvent.Lock()
	mock.calls.CreateContentItemAddedEvent = append(mock.calls.CreateContentItemAddedEvent, callInfo)
	mock.lockCreateContentItemAddedEvent.Unlock()
	return mock.CreateContentItemAddedEventFunc(ctx, r, contentItem)
}

// CreateContentItemAddedEventCalls gets all the calls that were made to CreateContentItemAddedEvent.
// Check the length with:
//
//	len(mockedBundleEventsManager.CreateContentItemAddedEventCalls())
func (mock *BundleEventsManagerMock) CreateContentItemAddedEventCalls() []struct {
	Ctx         context.Context
	R           *http.Request
	ContentItem *models.ContentItem
} {
	var calls []struct {
		Ctx         context.Context
		R           *http.Request
		ContentItem *models.ContentItem
	}
	mock.lockCreateContentItemAddedEvent.RLock()
	calls = mock.calls.CreateContentItemAddedEvent
	mock.lockCreateContentItemAddedEvent.RUnlock()
	return calls
}

// InsertContentItemUpdatedEvent calls CreateContentItemUpdatedEventFunc.
func (mock *BundleEventsManagerMock) InsertContentItemUpdatedEvent(ctx context.Context, r *http.Request, contentItem *models.ContentItem) *models.Error {
	if mock.CreateContentItemUpdatedEventFunc == nil {
		panic("BundleEventsManagerMock.CreateContentItemUpdatedEventFunc: method is nil but BundleEventsManager.CreateContentItemUpdatedEvent was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		R           *http.Request
		ContentItem *models.ContentItem
	}{
		Ctx:         ctx,
		R:           r,
		ContentItem: contentItem,
	}
	mock.lockCreateContentItemUpdatedEvent.Lock()
	mock.calls.CreateContentItemUpdatedEvent = append(mock.calls.CreateContentItemUpdatedEvent, callInfo)
	mock.lockCreateContentItemUpdatedEvent.Unlock()
	return mock.CreateContentItemUpdatedEventFunc(ctx, r, contentItem)
}

// CreateContentItemUpdatedEventCalls gets all the calls that were made to CreateContentItemUpdatedEvent.
// Check the length with:
//
//	len(mockedBundleEventsManager.CreateContentItemUpdatedEventCalls())
func (mock *BundleEventsManagerMock) CreateContentItemUpdatedEventCalls() []struct {
	Ctx         context.Context
	R           *http.Request
	ContentItem *models.ContentItem
} {
	var calls []struct {
		Ctx         context.Context
		R           *http.Request
		ContentItem *models.ContentItem
	}
	mock.lockCreateContentItemUpdatedEvent.RLock()
	calls = mock.calls.CreateContentItemUpdatedEvent
	mock.lockCreateContentItemUpdatedEvent.RUnlock()
	return calls
}
