package models

import (
	"bytes"
	"encoding/json"
	"errors"
	"testing"

	errs "github.com/ONSdigital/dis-bundle-api/apierrors"
	"github.com/gofrs/uuid"
	. "github.com/smartystreets/goconvey/convey"
)

var contentItemStateApproved = StateApproved
var contentItemStateInvalid = State("Invalid")

var fullyPopulatedContentItem = ContentItem{
	ID:          "123", // This ID will be a UUID generated by the CreateContentItem function
	BundleID:    "456",
	ContentType: ContentTypeDataset,
	Metadata: Metadata{
		DatasetID: "dataset-id",
		EditionID: "edition-id",
		Title:     "title",
		VersionID: 1,
	},
	State: &contentItemStateApproved,
	Links: Links{
		Edit:    "/edit",
		Preview: "/preview",
	},
}

var minimallyPopulatedContentItem = ContentItem{
	BundleID:    "789",
	ContentType: ContentTypeDataset,
	Metadata: Metadata{
		DatasetID: "dataset-id",
		EditionID: "edition-id",
		Title:     "title",
		VersionID: 1,
	},
	Links: Links{
		Edit:    "/edit",
		Preview: "/preview",
	},
}

func TestCreateContentItem_Success(t *testing.T) {
	Convey("Given a fully populated ContentItem", t, func() {
		b, err := json.Marshal(fullyPopulatedContentItem)
		So(err, ShouldBeNil)

		reader := bytes.NewReader(b)

		Convey("When CreateContentItem is called", func() {
			contentItem, err := CreateContentItem(reader)
			So(err, ShouldBeNil)

			Convey("Then it should return a ContentItem with the expected values", func() {
				So(contentItem.ID, ShouldNotBeEmpty)
				_, err := uuid.FromString(contentItem.ID)
				So(err, ShouldBeNil)
				So(contentItem.BundleID, ShouldEqual, fullyPopulatedContentItem.BundleID)
				So(contentItem.ContentType, ShouldEqual, fullyPopulatedContentItem.ContentType)
				So(contentItem.Metadata, ShouldResemble, fullyPopulatedContentItem.Metadata)
				So(contentItem.State, ShouldEqual, fullyPopulatedContentItem.State)
				So(contentItem.Links, ShouldResemble, fullyPopulatedContentItem.Links)
			})
		})
	})

	Convey("Given a minimally populated ContentItem", t, func() {
		b, err := json.Marshal(minimallyPopulatedContentItem)
		So(err, ShouldBeNil)

		reader := bytes.NewReader(b)

		Convey("When CreateContentItem is called", func() {
			contentItem, err := CreateContentItem(reader)
			So(err, ShouldBeNil)

			Convey("Then it should return a ContentItem with the expected values", func() {
				So(contentItem.ID, ShouldNotBeEmpty)
				_, err := uuid.FromString(contentItem.ID)
				So(err, ShouldBeNil)
				So(contentItem.BundleID, ShouldEqual, minimallyPopulatedContentItem.BundleID)
				So(contentItem.ContentType, ShouldEqual, minimallyPopulatedContentItem.ContentType)
				So(contentItem.Metadata, ShouldResemble, minimallyPopulatedContentItem.Metadata)
				So(contentItem.State, ShouldBeNil)
				So(contentItem.Links, ShouldResemble, minimallyPopulatedContentItem.Links)
			})
		})
	})
}

func TestCreateContentItem_Failure(t *testing.T) {
	Convey("Given a reader that returns an error", t, func() {
		errorReader := &ErrorReader{}

		Convey("When CreateContentItem is called", func() {
			_, err := CreateContentItem(errorReader)

			Convey("Then it should return an error indicating it was unable to read the message", func() {
				So(err, ShouldNotBeNil)
				So(err.Error(), ShouldEqual, errs.ErrUnableToReadMessage.Error())
			})
		})
	})

	Convey("Given a reader with invalid JSON", t, func() {
		invalidJSON := `{"bundle_id": "123}`
		reader := bytes.NewReader([]byte(invalidJSON))

		Convey("When CreateContentItem is called", func() {
			_, err := CreateContentItem(reader)

			Convey("Then it should return an error indicating it was unable to parse JSON", func() {
				So(err, ShouldNotBeNil)
				So(err.Error(), ShouldEqual, errs.ErrUnableToParseJSON.Error())
			})
		})
	})

	Convey("Given a valid ContentItem", t, func() {
		b, err := json.Marshal(fullyPopulatedContentItem)
		So(err, ShouldBeNil)

		reader := bytes.NewReader(b)

		Convey("When CreateContentItem is called and the UUID generator fails", func() {
			originalNewUUID := newUUID

			newUUID = func() (uuid.UUID, error) {
				return uuid.UUID{}, errors.New("simulated UUID generation failure")
			}
			defer func() {
				newUUID = originalNewUUID
			}()

			item, err := CreateContentItem(reader)

			Convey("Then it should return an error and no item should be created", func() {
				So(err, ShouldNotBeNil)
				So(err.Error(), ShouldEqual, "simulated UUID generation failure")
				So(item, ShouldBeNil)
			})
		})
	})
}

func TestValidateContentItem_Success(t *testing.T) {
	Convey("Given a fully populated ContentItem", t, func() {
		contentItem := fullyPopulatedContentItem

		Convey("When ValidateContentItem is called", func() {
			err := ValidateContentItem(&contentItem)

			Convey("Then it should not return an error", func() {
				So(err, ShouldBeNil)
			})
		})
	})

	Convey("Given a minimally populated ContentItem", t, func() {
		contentItem := minimallyPopulatedContentItem

		Convey("When ValidateContentItem is called", func() {
			err := ValidateContentItem(&contentItem)

			Convey("Then it should not return an error", func() {
				So(err, ShouldBeNil)
			})
		})
	})
}

func TestValidateContentItem_Failure(t *testing.T) {
	Convey("Given a ContentItem with missing mandatory fields", t, func() {
		contentItem := ContentItem{}

		Convey("When ValidateContentItem is called", func() {
			err := ValidateContentItem(&contentItem)

			Convey("Then it should return an error indicating the missing fields", func() {
				So(err, ShouldNotBeNil)
				So(err.Error(), ShouldEqual, "missing mandatory fields: [bundle_id content_type metadata.dataset_id metadata.edition_id links.edit links.preview]")
			})
		})
	})

	Convey("Given a ContentItem with invalid fields", t, func() {
		contentItem := fullyPopulatedContentItem
		contentItem.ContentType = "invalid_content_type"
		contentItem.Metadata.VersionID = -1
		contentItem.State = &contentItemStateInvalid

		Convey("When ValidateContentItem is called", func() {
			err := ValidateContentItem(&contentItem)

			Convey("Then it should return an error indicating the invalid fields", func() {
				So(err, ShouldNotBeNil)
				So(err.Error(), ShouldEqual, "invalid fields: [content_type metadata.version_id state]")
			})
		})
	})
}
