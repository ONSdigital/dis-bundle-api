package models

import (
	"bytes"
	"encoding/json"
	"errors"
	"testing"

	errs "github.com/ONSdigital/dis-bundle-api/apierrors"
	"github.com/gofrs/uuid"
	. "github.com/smartystreets/goconvey/convey"
)

var contentItemStateApproved = StateApproved
var contentItemStateInvalid = State("Invalid")

var fullyPopulatedContentItem = ContentItem{
	ID:          "123", // This ID will be a UUID generated by the CreateContentItem function
	BundleID:    "456",
	ContentType: ContentTypeDataset,
	Metadata: Metadata{
		DatasetID: "dataset-id",
		EditionID: "edition-id",
		Title:     "title",
		VersionID: 1,
	},
	State: &contentItemStateApproved,
	Links: Links{
		Edit:    "/edit",
		Preview: "/preview",
	},
}

var minimallyPopulatedContentItem = ContentItem{
	BundleID:    "789",
	ContentType: ContentTypeDataset,
	Metadata: Metadata{
		DatasetID: "dataset-id",
		EditionID: "edition-id",
		Title:     "title",
		VersionID: 1,
	},
	Links: Links{
		Edit:    "/edit",
		Preview: "/preview",
	},
}

func TestCreateContentItem_Success(t *testing.T) {
	Convey("Given a fully populated ContentItem", t, func() {
		b, err := json.Marshal(fullyPopulatedContentItem)
		So(err, ShouldBeNil)

		reader := bytes.NewReader(b)

		Convey("When CreateContentItem is called", func() {
			contentItem, err := CreateContentItem(reader)
			So(err, ShouldBeNil)

			Convey("Then it should return a ContentItem with the expected values", func() {
				So(contentItem.ID, ShouldNotBeEmpty)
				_, err := uuid.FromString(contentItem.ID)
				So(err, ShouldBeNil)
				So(contentItem.BundleID, ShouldEqual, fullyPopulatedContentItem.BundleID)
				So(contentItem.ContentType, ShouldEqual, fullyPopulatedContentItem.ContentType)
				So(contentItem.Metadata, ShouldResemble, fullyPopulatedContentItem.Metadata)
				So(contentItem.State, ShouldEqual, fullyPopulatedContentItem.State)
				So(contentItem.Links, ShouldResemble, fullyPopulatedContentItem.Links)
			})
		})
	})

	Convey("Given a minimally populated ContentItem", t, func() {
		b, err := json.Marshal(minimallyPopulatedContentItem)
		So(err, ShouldBeNil)

		reader := bytes.NewReader(b)

		Convey("When CreateContentItem is called", func() {
			contentItem, err := CreateContentItem(reader)
			So(err, ShouldBeNil)

			Convey("Then it should return a ContentItem with the expected values", func() {
				So(contentItem.ID, ShouldNotBeEmpty)
				_, err := uuid.FromString(contentItem.ID)
				So(err, ShouldBeNil)
				So(contentItem.BundleID, ShouldEqual, minimallyPopulatedContentItem.BundleID)
				So(contentItem.ContentType, ShouldEqual, minimallyPopulatedContentItem.ContentType)
				So(contentItem.Metadata, ShouldResemble, minimallyPopulatedContentItem.Metadata)
				So(contentItem.State, ShouldBeNil)
				So(contentItem.Links, ShouldResemble, minimallyPopulatedContentItem.Links)
			})
		})
	})
}

func TestCreateContentItem_Failure(t *testing.T) {
	Convey("Given a reader that returns an error", t, func() {
		errorReader := &ErrorReader{}

		Convey("When CreateContentItem is called", func() {
			_, err := CreateContentItem(errorReader)

			Convey("Then it should return an error indicating it was unable to read the message", func() {
				So(err, ShouldNotBeNil)
				So(err.Error(), ShouldEqual, errs.ErrUnableToReadMessage.Error())
			})
		})
	})

	Convey("Given a reader with invalid JSON", t, func() {
		invalidJSON := `{"bundle_id": "123}`
		reader := bytes.NewReader([]byte(invalidJSON))

		Convey("When CreateContentItem is called", func() {
			_, err := CreateContentItem(reader)

			Convey("Then it should return an error indicating it was unable to parse JSON", func() {
				So(err, ShouldNotBeNil)
				So(err.Error(), ShouldEqual, errs.ErrUnableToParseJSON.Error())
			})
		})
	})

	Convey("Given a valid ContentItem", t, func() {
		b, err := json.Marshal(fullyPopulatedContentItem)
		So(err, ShouldBeNil)

		reader := bytes.NewReader(b)

		Convey("When CreateContentItem is called and the UUID generator fails", func() {
			originalNewUUID := newUUID

			newUUID = func() (uuid.UUID, error) {
				return uuid.UUID{}, errors.New("simulated UUID generation failure")
			}
			defer func() {
				newUUID = originalNewUUID
			}()

			item, err := CreateContentItem(reader)

			Convey("Then it should return an error and no item should be created", func() {
				So(err, ShouldNotBeNil)
				So(err.Error(), ShouldEqual, "simulated UUID generation failure")
				So(item, ShouldBeNil)
			})
		})
	})
}

func TestCleanContentItem_Success(t *testing.T) {
	Convey("Given a ContentItem with leading and trailing spaces in its fields", t, func() {
		stateApprovedWithWhitespace := State("  APPROVED  ")

		contentItem := &ContentItem{
			ID:          "  id  ",
			BundleID:    "  bundle-id  ",
			ContentType: ContentType("  DATASET  "),
			Metadata: Metadata{
				DatasetID: "  dataset-id  ",
				EditionID: "  edition-id  ",
				Title:     "  title  ",
			},
			State: &stateApprovedWithWhitespace,
			Links: Links{
				Edit:    "  edit-link  ",
				Preview: "  preview-link  ",
			},
		}

		Convey("When CleanContentItem is called", func() {
			CleanContentItem(contentItem)

			Convey("Then all fields should be trimmed of leading and trailing spaces", func() {
				So(contentItem.ID, ShouldEqual, "id")
				So(contentItem.BundleID, ShouldEqual, "bundle-id")
				So(contentItem.ContentType.String(), ShouldEqual, "DATASET")
				So(contentItem.Metadata.DatasetID, ShouldEqual, "dataset-id")
				So(contentItem.Metadata.EditionID, ShouldEqual, "edition-id")
				So(contentItem.Metadata.Title, ShouldEqual, "title")
				So(contentItem.State.String(), ShouldEqual, StateApproved.String())
				So(contentItem.Links.Edit, ShouldEqual, "edit-link")
				So(contentItem.Links.Preview, ShouldEqual, "preview-link")
			})
		})
	})
}

func TestValidateContentItem_Success(t *testing.T) {
	Convey("Given a fully populated ContentItem", t, func() {
		contentItem := fullyPopulatedContentItem

		Convey("When ValidateContentItem is called", func() {
			err := ValidateContentItem(&contentItem)

			Convey("Then it should not return an error", func() {
				So(err, ShouldBeNil)
			})
		})
	})

	Convey("Given a minimally populated ContentItem", t, func() {
		contentItem := minimallyPopulatedContentItem

		Convey("When ValidateContentItem is called", func() {
			err := ValidateContentItem(&contentItem)

			Convey("Then it should not return an error", func() {
				So(err, ShouldBeNil)
			})
		})
	})
}

func TestValidateContentItem_Failure(t *testing.T) {
	Convey("Given a ContentItem with missing mandatory fields", t, func() {
		contentItem := ContentItem{}

		Convey("When ValidateContentItem is called", func() {
			err := ValidateContentItem(&contentItem)

			Convey("Then it should return an error indicating the missing fields", func() {
				So(err, ShouldNotBeNil)
				So(err[0].Source.Field, ShouldEqual, "/bundle_id")
				So(err[1].Source.Field, ShouldEqual, "/content_type")
				So(err[2].Source.Field, ShouldEqual, "/metadata/dataset_id")
				So(err[3].Source.Field, ShouldEqual, "/metadata/edition_id")
				So(err[4].Source.Field, ShouldEqual, "/links/edit")
				So(err[5].Source.Field, ShouldEqual, "/links/preview")
			})
		})
	})

	Convey("Given a ContentItem with invalid fields", t, func() {
		contentItem := fullyPopulatedContentItem
		contentItem.ContentType = "invalid_content_type"
		contentItem.Metadata.VersionID = -1
		contentItem.State = &contentItemStateInvalid

		Convey("When ValidateContentItem is called", func() {
			err := ValidateContentItem(&contentItem)

			Convey("Then it should return an error indicating the invalid fields", func() {
				So(err, ShouldNotBeNil)
				So(err[0].Source.Field, ShouldEqual, "/content_type")
				So(err[1].Source.Field, ShouldEqual, "/metadata/version_id")
				So(err[2].Source.Field, ShouldEqual, "/state")
			})
		})
	})
}

func TestContentType_String_Success(t *testing.T) {
	Convey("Given a valid ContentType", t, func() {
		contentType := ContentTypeDataset

		Convey("When String is called", func() {
			str := contentType.String()

			Convey("Then it should return the correct string representation", func() {
				So(str, ShouldEqual, "DATASET")
			})
		})
	})
}

func TestState_String_Success(t *testing.T) {
	Convey("Given a valid State", t, func() {
		state := StateApproved

		Convey("When String is called", func() {
			str := state.String()

			Convey("Then it should return the correct string representation", func() {
				So(str, ShouldEqual, "APPROVED")
			})
		})
	})
}
