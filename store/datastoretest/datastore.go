// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storetest

import (
	"context"
	"github.com/ONSdigital/dis-bundle-api/filters"
	"github.com/ONSdigital/dis-bundle-api/models"
	"github.com/ONSdigital/dis-bundle-api/store"
	"github.com/ONSdigital/dp-healthcheck/healthcheck"
	"sync"
	"time"
)

// Ensure, that StorerMock does implement store.Storer.
// If this is not the case, regenerate this file with moq.
var _ store.Storer = &StorerMock{}

// StorerMock is a mock implementation of store.Storer.
//
//	func TestSomethingThatUsesStorer(t *testing.T) {
//
//		// make and configure a mocked store.Storer
//		mockedStorer := &StorerMock{
//			CheckAllBundleContentsAreApprovedFunc: func(ctx context.Context, bundleID string) (bool, error) {
//				panic("mock out the CheckAllBundleContentsAreApproved method")
//			},
//			CheckBundleExistsFunc: func(ctx context.Context, bundleID string) (bool, error) {
//				panic("mock out the CheckBundleExists method")
//			},
//			CheckContentItemExistsByDatasetEditionVersionFunc: func(ctx context.Context, datasetID string, editionID string, versionID int) (bool, error) {
//				panic("mock out the CheckContentItemExistsByDatasetEditionVersion method")
//			},
//			CheckerFunc: func(ctx context.Context, state *healthcheck.CheckState) error {
//				panic("mock out the Checker method")
//			},
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			CreateBundleEventFunc: func(ctx context.Context, event *models.Event) error {
//				panic("mock out the CreateBundleEvent method")
//			},
//			CreateContentItemFunc: func(ctx context.Context, contentItem *models.ContentItem) error {
//				panic("mock out the CreateContentItem method")
//			},
//			GetBundleFunc: func(ctx context.Context, bundleID string) (*models.Bundle, error) {
//				panic("mock out the GetBundle method")
//			},
//			GetContentsForBundleFunc: func(ctx context.Context, bundleID string) ([]models.ContentItem, error) {
//				panic("mock out the GetContentsForBundle method")
//			},
//			ListBundleEventsFunc: func(ctx context.Context, offset int, limit int, bundleID string, after *time.Time, before *time.Time) ([]*models.Event, int, error) {
//				panic("mock out the ListBundleEvents method")
//			},
//			ListBundlesFunc: func(ctx context.Context, offset int, limit int, filtersMoqParam *filters.BundleFilters) ([]*models.Bundle, int, error) {
//				panic("mock out the ListBundles method")
//			},
//			UpdateBundleContentItemStateFunc: func(ctx context.Context, contentItemID string, state models.BundleState) error {
//				panic("mock out the UpdateBundleContentItemState method")
//			},
//			UpdateBundleETagFunc: func(ctx context.Context, bundleID string, email string) (*models.Bundle, error) {
//				panic("mock out the UpdateBundleETag method")
//			},
//			UpdateBundleStateFunc: func(ctx context.Context, bundleID string, state models.BundleState) error {
//				panic("mock out the UpdateBundleState method")
//			},
//		}
//
//		// use mockedStorer in code that requires store.Storer
//		// and then make assertions.
//
//	}
type StorerMock struct {
	// CheckAllBundleContentsAreApprovedFunc mocks the CheckAllBundleContentsAreApproved method.
	CheckAllBundleContentsAreApprovedFunc func(ctx context.Context, bundleID string) (bool, error)

	// CheckBundleExistsFunc mocks the CheckBundleExists method.
	CheckBundleExistsFunc func(ctx context.Context, bundleID string) (bool, error)

	// CheckContentItemExistsByDatasetEditionVersionFunc mocks the CheckContentItemExistsByDatasetEditionVersion method.
	CheckContentItemExistsByDatasetEditionVersionFunc func(ctx context.Context, datasetID string, editionID string, versionID int) (bool, error)

	// CheckerFunc mocks the Checker method.
	CheckerFunc func(ctx context.Context, state *healthcheck.CheckState) error

	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// CreateBundleEventFunc mocks the CreateBundleEvent method.
	CreateBundleEventFunc func(ctx context.Context, event *models.Event) error

	// CreateContentItemFunc mocks the CreateContentItem method.
	CreateContentItemFunc func(ctx context.Context, contentItem *models.ContentItem) error

	// GetBundleFunc mocks the GetBundle method.
	GetBundleFunc func(ctx context.Context, bundleID string) (*models.Bundle, error)

	// GetContentsForBundleFunc mocks the GetContentsForBundle method.
	GetContentsForBundleFunc func(ctx context.Context, bundleID string) ([]models.ContentItem, error)

	// ListBundleEventsFunc mocks the ListBundleEvents method.
	ListBundleEventsFunc func(ctx context.Context, offset int, limit int, bundleID string, after *time.Time, before *time.Time) ([]*models.Event, int, error)

	// ListBundlesFunc mocks the ListBundles method.
	ListBundlesFunc func(ctx context.Context, offset int, limit int, filtersMoqParam *filters.BundleFilters) ([]*models.Bundle, int, error)

	// UpdateBundleContentItemStateFunc mocks the UpdateBundleContentItemState method.
	UpdateBundleContentItemStateFunc func(ctx context.Context, contentItemID string, state models.BundleState) error

	// UpdateBundleETagFunc mocks the UpdateBundleETag method.
	UpdateBundleETagFunc func(ctx context.Context, bundleID string, email string) (*models.Bundle, error)

	// UpdateBundleStateFunc mocks the UpdateBundleState method.
	UpdateBundleStateFunc func(ctx context.Context, bundleID string, state models.BundleState) error

	// calls tracks calls to the methods.
	calls struct {
		// CheckAllBundleContentsAreApproved holds details about calls to the CheckAllBundleContentsAreApproved method.
		CheckAllBundleContentsAreApproved []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
		}
		// CheckBundleExists holds details about calls to the CheckBundleExists method.
		CheckBundleExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
		}
		// CheckContentItemExistsByDatasetEditionVersion holds details about calls to the CheckContentItemExistsByDatasetEditionVersion method.
		CheckContentItemExistsByDatasetEditionVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// VersionID is the versionID argument value.
			VersionID int
		}
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// State is the state argument value.
			State *healthcheck.CheckState
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateBundleEvent holds details about calls to the CreateBundleEvent method.
		CreateBundleEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *models.Event
		}
		// CreateContentItem holds details about calls to the CreateContentItem method.
		CreateContentItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ContentItem is the contentItem argument value.
			ContentItem *models.ContentItem
		}
		// GetBundle holds details about calls to the GetBundle method.
		GetBundle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
		}
		// GetContentsForBundle holds details about calls to the GetContentsForBundle method.
		GetContentsForBundle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
		}
		// ListBundleEvents holds details about calls to the ListBundleEvents method.
		ListBundleEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// BundleID is the bundleID argument value.
			BundleID string
			// After is the after argument value.
			After *time.Time
			// Before is the before argument value.
			Before *time.Time
		}
		// ListBundles holds details about calls to the ListBundles method.
		ListBundles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// FiltersMoqParam is the filtersMoqParam argument value.
			FiltersMoqParam *filters.BundleFilters
		}
		// UpdateBundleContentItemState holds details about calls to the UpdateBundleContentItemState method.
		UpdateBundleContentItemState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ContentItemID is the contentItemID argument value.
			ContentItemID string
			// State is the state argument value.
			State models.BundleState
		}
		// UpdateBundleETag holds details about calls to the UpdateBundleETag method.
		UpdateBundleETag []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
			// Email is the email argument value.
			Email string
		}
		// UpdateBundleState holds details about calls to the UpdateBundleState method.
		UpdateBundleState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
			// State is the state argument value.
			State models.BundleState
		}
	}
	lockCheckAllBundleContentsAreApproved             sync.RWMutex
	lockCheckBundleExists                             sync.RWMutex
	lockCheckContentItemExistsByDatasetEditionVersion sync.RWMutex
	lockChecker                                       sync.RWMutex
	lockClose                                         sync.RWMutex
	lockCreateBundleEvent                             sync.RWMutex
	lockCreateContentItem                             sync.RWMutex
	lockGetBundle                                     sync.RWMutex
	lockGetContentsForBundle                          sync.RWMutex
	lockListBundleEvents                              sync.RWMutex
	lockListBundles                                   sync.RWMutex
	lockUpdateBundleContentItemState                  sync.RWMutex
	lockUpdateBundleETag                              sync.RWMutex
	lockUpdateBundleState                             sync.RWMutex
}

// CheckAllBundleContentsAreApproved calls CheckAllBundleContentsAreApprovedFunc.
func (mock *StorerMock) CheckAllBundleContentsAreApproved(ctx context.Context, bundleID string) (bool, error) {
	if mock.CheckAllBundleContentsAreApprovedFunc == nil {
		panic("StorerMock.CheckAllBundleContentsAreApprovedFunc: method is nil but Storer.CheckAllBundleContentsAreApproved was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
	}
	mock.lockCheckAllBundleContentsAreApproved.Lock()
	mock.calls.CheckAllBundleContentsAreApproved = append(mock.calls.CheckAllBundleContentsAreApproved, callInfo)
	mock.lockCheckAllBundleContentsAreApproved.Unlock()
	return mock.CheckAllBundleContentsAreApprovedFunc(ctx, bundleID)
}

// CheckAllBundleContentsAreApprovedCalls gets all the calls that were made to CheckAllBundleContentsAreApproved.
// Check the length with:
//
//	len(mockedStorer.CheckAllBundleContentsAreApprovedCalls())
func (mock *StorerMock) CheckAllBundleContentsAreApprovedCalls() []struct {
	Ctx      context.Context
	BundleID string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
	}
	mock.lockCheckAllBundleContentsAreApproved.RLock()
	calls = mock.calls.CheckAllBundleContentsAreApproved
	mock.lockCheckAllBundleContentsAreApproved.RUnlock()
	return calls
}

// CheckBundleExists calls CheckBundleExistsFunc.
func (mock *StorerMock) CheckBundleExists(ctx context.Context, bundleID string) (bool, error) {
	if mock.CheckBundleExistsFunc == nil {
		panic("StorerMock.CheckBundleExistsFunc: method is nil but Storer.CheckBundleExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
	}
	mock.lockCheckBundleExists.Lock()
	mock.calls.CheckBundleExists = append(mock.calls.CheckBundleExists, callInfo)
	mock.lockCheckBundleExists.Unlock()
	return mock.CheckBundleExistsFunc(ctx, bundleID)
}

// CheckBundleExistsCalls gets all the calls that were made to CheckBundleExists.
// Check the length with:
//
//	len(mockedStorer.CheckBundleExistsCalls())
func (mock *StorerMock) CheckBundleExistsCalls() []struct {
	Ctx      context.Context
	BundleID string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
	}
	mock.lockCheckBundleExists.RLock()
	calls = mock.calls.CheckBundleExists
	mock.lockCheckBundleExists.RUnlock()
	return calls
}

// CheckContentItemExistsByDatasetEditionVersion calls CheckContentItemExistsByDatasetEditionVersionFunc.
func (mock *StorerMock) CheckContentItemExistsByDatasetEditionVersion(ctx context.Context, datasetID string, editionID string, versionID int) (bool, error) {
	if mock.CheckContentItemExistsByDatasetEditionVersionFunc == nil {
		panic("StorerMock.CheckContentItemExistsByDatasetEditionVersionFunc: method is nil but Storer.CheckContentItemExistsByDatasetEditionVersion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		VersionID int
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
		VersionID: versionID,
	}
	mock.lockCheckContentItemExistsByDatasetEditionVersion.Lock()
	mock.calls.CheckContentItemExistsByDatasetEditionVersion = append(mock.calls.CheckContentItemExistsByDatasetEditionVersion, callInfo)
	mock.lockCheckContentItemExistsByDatasetEditionVersion.Unlock()
	return mock.CheckContentItemExistsByDatasetEditionVersionFunc(ctx, datasetID, editionID, versionID)
}

// CheckContentItemExistsByDatasetEditionVersionCalls gets all the calls that were made to CheckContentItemExistsByDatasetEditionVersion.
// Check the length with:
//
//	len(mockedStorer.CheckContentItemExistsByDatasetEditionVersionCalls())
func (mock *StorerMock) CheckContentItemExistsByDatasetEditionVersionCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
	VersionID int
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		VersionID int
	}
	mock.lockCheckContentItemExistsByDatasetEditionVersion.RLock()
	calls = mock.calls.CheckContentItemExistsByDatasetEditionVersion
	mock.lockCheckContentItemExistsByDatasetEditionVersion.RUnlock()
	return calls
}

// Checker calls CheckerFunc.
func (mock *StorerMock) Checker(ctx context.Context, state *healthcheck.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("StorerMock.CheckerFunc: method is nil but Storer.Checker was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}{
		Ctx:   ctx,
		State: state,
	}
	mock.lockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	mock.lockChecker.Unlock()
	return mock.CheckerFunc(ctx, state)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//
//	len(mockedStorer.CheckerCalls())
func (mock *StorerMock) CheckerCalls() []struct {
	Ctx   context.Context
	State *healthcheck.CheckState
} {
	var calls []struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}
	mock.lockChecker.RLock()
	calls = mock.calls.Checker
	mock.lockChecker.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *StorerMock) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("StorerMock.CloseFunc: method is nil but Storer.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedStorer.CloseCalls())
func (mock *StorerMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CreateBundleEvent calls CreateBundleEventFunc.
func (mock *StorerMock) CreateBundleEvent(ctx context.Context, event *models.Event) error {
	if mock.CreateBundleEventFunc == nil {
		panic("StorerMock.CreateBundleEventFunc: method is nil but Storer.CreateBundleEvent was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *models.Event
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockCreateBundleEvent.Lock()
	mock.calls.CreateBundleEvent = append(mock.calls.CreateBundleEvent, callInfo)
	mock.lockCreateBundleEvent.Unlock()
	return mock.CreateBundleEventFunc(ctx, event)
}

// CreateBundleEventCalls gets all the calls that were made to CreateBundleEvent.
// Check the length with:
//
//	len(mockedStorer.CreateBundleEventCalls())
func (mock *StorerMock) CreateBundleEventCalls() []struct {
	Ctx   context.Context
	Event *models.Event
} {
	var calls []struct {
		Ctx   context.Context
		Event *models.Event
	}
	mock.lockCreateBundleEvent.RLock()
	calls = mock.calls.CreateBundleEvent
	mock.lockCreateBundleEvent.RUnlock()
	return calls
}

// CreateContentItem calls CreateContentItemFunc.
func (mock *StorerMock) CreateContentItem(ctx context.Context, contentItem *models.ContentItem) error {
	if mock.CreateContentItemFunc == nil {
		panic("StorerMock.CreateContentItemFunc: method is nil but Storer.CreateContentItem was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ContentItem *models.ContentItem
	}{
		Ctx:         ctx,
		ContentItem: contentItem,
	}
	mock.lockCreateContentItem.Lock()
	mock.calls.CreateContentItem = append(mock.calls.CreateContentItem, callInfo)
	mock.lockCreateContentItem.Unlock()
	return mock.CreateContentItemFunc(ctx, contentItem)
}

// CreateContentItemCalls gets all the calls that were made to CreateContentItem.
// Check the length with:
//
//	len(mockedStorer.CreateContentItemCalls())
func (mock *StorerMock) CreateContentItemCalls() []struct {
	Ctx         context.Context
	ContentItem *models.ContentItem
} {
	var calls []struct {
		Ctx         context.Context
		ContentItem *models.ContentItem
	}
	mock.lockCreateContentItem.RLock()
	calls = mock.calls.CreateContentItem
	mock.lockCreateContentItem.RUnlock()
	return calls
}

// GetBundle calls GetBundleFunc.
func (mock *StorerMock) GetBundle(ctx context.Context, bundleID string) (*models.Bundle, error) {
	if mock.GetBundleFunc == nil {
		panic("StorerMock.GetBundleFunc: method is nil but Storer.GetBundle was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
	}
	mock.lockGetBundle.Lock()
	mock.calls.GetBundle = append(mock.calls.GetBundle, callInfo)
	mock.lockGetBundle.Unlock()
	return mock.GetBundleFunc(ctx, bundleID)
}

// GetBundleCalls gets all the calls that were made to GetBundle.
// Check the length with:
//
//	len(mockedStorer.GetBundleCalls())
func (mock *StorerMock) GetBundleCalls() []struct {
	Ctx      context.Context
	BundleID string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
	}
	mock.lockGetBundle.RLock()
	calls = mock.calls.GetBundle
	mock.lockGetBundle.RUnlock()
	return calls
}

// GetContentsForBundle calls GetContentsForBundleFunc.
func (mock *StorerMock) GetContentsForBundle(ctx context.Context, bundleID string) ([]models.ContentItem, error) {
	if mock.GetContentsForBundleFunc == nil {
		panic("StorerMock.GetContentsForBundleFunc: method is nil but Storer.GetContentsForBundle was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
	}
	mock.lockGetContentsForBundle.Lock()
	mock.calls.GetContentsForBundle = append(mock.calls.GetContentsForBundle, callInfo)
	mock.lockGetContentsForBundle.Unlock()
	return mock.GetContentsForBundleFunc(ctx, bundleID)
}

// GetContentsForBundleCalls gets all the calls that were made to GetContentsForBundle.
// Check the length with:
//
//	len(mockedStorer.GetContentsForBundleCalls())
func (mock *StorerMock) GetContentsForBundleCalls() []struct {
	Ctx      context.Context
	BundleID string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
	}
	mock.lockGetContentsForBundle.RLock()
	calls = mock.calls.GetContentsForBundle
	mock.lockGetContentsForBundle.RUnlock()
	return calls
}

// ListBundleEvents calls ListBundleEventsFunc.
func (mock *StorerMock) ListBundleEvents(ctx context.Context, offset int, limit int, bundleID string, after *time.Time, before *time.Time) ([]*models.Event, int, error) {
	if mock.ListBundleEventsFunc == nil {
		panic("StorerMock.ListBundleEventsFunc: method is nil but Storer.ListBundleEvents was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Offset   int
		Limit    int
		BundleID string
		After    *time.Time
		Before   *time.Time
	}{
		Ctx:      ctx,
		Offset:   offset,
		Limit:    limit,
		BundleID: bundleID,
		After:    after,
		Before:   before,
	}
	mock.lockListBundleEvents.Lock()
	mock.calls.ListBundleEvents = append(mock.calls.ListBundleEvents, callInfo)
	mock.lockListBundleEvents.Unlock()
	return mock.ListBundleEventsFunc(ctx, offset, limit, bundleID, after, before)
}

// ListBundleEventsCalls gets all the calls that were made to ListBundleEvents.
// Check the length with:
//
//	len(mockedStorer.ListBundleEventsCalls())
func (mock *StorerMock) ListBundleEventsCalls() []struct {
	Ctx      context.Context
	Offset   int
	Limit    int
	BundleID string
	After    *time.Time
	Before   *time.Time
} {
	var calls []struct {
		Ctx      context.Context
		Offset   int
		Limit    int
		BundleID string
		After    *time.Time
		Before   *time.Time
	}
	mock.lockListBundleEvents.RLock()
	calls = mock.calls.ListBundleEvents
	mock.lockListBundleEvents.RUnlock()
	return calls
}

// ListBundles calls ListBundlesFunc.
func (mock *StorerMock) ListBundles(ctx context.Context, offset int, limit int, filtersMoqParam *filters.BundleFilters) ([]*models.Bundle, int, error) {
	if mock.ListBundlesFunc == nil {
		panic("StorerMock.ListBundlesFunc: method is nil but Storer.ListBundles was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Offset          int
		Limit           int
		FiltersMoqParam *filters.BundleFilters
	}{
		Ctx:             ctx,
		Offset:          offset,
		Limit:           limit,
		FiltersMoqParam: filtersMoqParam,
	}
	mock.lockListBundles.Lock()
	mock.calls.ListBundles = append(mock.calls.ListBundles, callInfo)
	mock.lockListBundles.Unlock()
	return mock.ListBundlesFunc(ctx, offset, limit, filtersMoqParam)
}

// ListBundlesCalls gets all the calls that were made to ListBundles.
// Check the length with:
//
//	len(mockedStorer.ListBundlesCalls())
func (mock *StorerMock) ListBundlesCalls() []struct {
	Ctx             context.Context
	Offset          int
	Limit           int
	FiltersMoqParam *filters.BundleFilters
} {
	var calls []struct {
		Ctx             context.Context
		Offset          int
		Limit           int
		FiltersMoqParam *filters.BundleFilters
	}
	mock.lockListBundles.RLock()
	calls = mock.calls.ListBundles
	mock.lockListBundles.RUnlock()
	return calls
}

// UpdateBundleContentItemState calls UpdateBundleContentItemStateFunc.
func (mock *StorerMock) UpdateBundleContentItemState(ctx context.Context, contentItemID string, state models.BundleState) error {
	if mock.UpdateBundleContentItemStateFunc == nil {
		panic("StorerMock.UpdateBundleContentItemStateFunc: method is nil but Storer.UpdateBundleContentItemState was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ContentItemID string
		State         models.BundleState
	}{
		Ctx:           ctx,
		ContentItemID: contentItemID,
		State:         state,
	}
	mock.lockUpdateBundleContentItemState.Lock()
	mock.calls.UpdateBundleContentItemState = append(mock.calls.UpdateBundleContentItemState, callInfo)
	mock.lockUpdateBundleContentItemState.Unlock()
	return mock.UpdateBundleContentItemStateFunc(ctx, contentItemID, state)
}

// UpdateBundleContentItemStateCalls gets all the calls that were made to UpdateBundleContentItemState.
// Check the length with:
//
//	len(mockedStorer.UpdateBundleContentItemStateCalls())
func (mock *StorerMock) UpdateBundleContentItemStateCalls() []struct {
	Ctx           context.Context
	ContentItemID string
	State         models.BundleState
} {
	var calls []struct {
		Ctx           context.Context
		ContentItemID string
		State         models.BundleState
	}
	mock.lockUpdateBundleContentItemState.RLock()
	calls = mock.calls.UpdateBundleContentItemState
	mock.lockUpdateBundleContentItemState.RUnlock()
	return calls
}

// UpdateBundleETag calls UpdateBundleETagFunc.
func (mock *StorerMock) UpdateBundleETag(ctx context.Context, bundleID string, email string) (*models.Bundle, error) {
	if mock.UpdateBundleETagFunc == nil {
		panic("StorerMock.UpdateBundleETagFunc: method is nil but Storer.UpdateBundleETag was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
		Email    string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
		Email:    email,
	}
	mock.lockUpdateBundleETag.Lock()
	mock.calls.UpdateBundleETag = append(mock.calls.UpdateBundleETag, callInfo)
	mock.lockUpdateBundleETag.Unlock()
	return mock.UpdateBundleETagFunc(ctx, bundleID, email)
}

// UpdateBundleETagCalls gets all the calls that were made to UpdateBundleETag.
// Check the length with:
//
//	len(mockedStorer.UpdateBundleETagCalls())
func (mock *StorerMock) UpdateBundleETagCalls() []struct {
	Ctx      context.Context
	BundleID string
	Email    string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
		Email    string
	}
	mock.lockUpdateBundleETag.RLock()
	calls = mock.calls.UpdateBundleETag
	mock.lockUpdateBundleETag.RUnlock()
	return calls
}

// UpdateBundleState calls UpdateBundleStateFunc.
func (mock *StorerMock) UpdateBundleState(ctx context.Context, bundleID string, state models.BundleState) error {
	if mock.UpdateBundleStateFunc == nil {
		panic("StorerMock.UpdateBundleStateFunc: method is nil but Storer.UpdateBundleState was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
		State    models.BundleState
	}{
		Ctx:      ctx,
		BundleID: bundleID,
		State:    state,
	}
	mock.lockUpdateBundleState.Lock()
	mock.calls.UpdateBundleState = append(mock.calls.UpdateBundleState, callInfo)
	mock.lockUpdateBundleState.Unlock()
	return mock.UpdateBundleStateFunc(ctx, bundleID, state)
}

// UpdateBundleStateCalls gets all the calls that were made to UpdateBundleState.
// Check the length with:
//
//	len(mockedStorer.UpdateBundleStateCalls())
func (mock *StorerMock) UpdateBundleStateCalls() []struct {
	Ctx      context.Context
	BundleID string
	State    models.BundleState
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
		State    models.BundleState
	}
	mock.lockUpdateBundleState.RLock()
	calls = mock.calls.UpdateBundleState
	mock.lockUpdateBundleState.RUnlock()
	return calls
}
