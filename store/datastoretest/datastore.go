// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storetest

import (
	"context"
	"github.com/ONSdigital/dis-bundle-api/filters"
	"github.com/ONSdigital/dis-bundle-api/models"
	"github.com/ONSdigital/dis-bundle-api/store"
	"github.com/ONSdigital/dp-healthcheck/healthcheck"
	"sync"
	"time"
)

// Ensure, that StorerMock does implement store.Storer.
// If this is not the case, regenerate this file with moq.
var _ store.Storer = &StorerMock{}

// StorerMock is a mock implementation of store.Storer.
//
//	func TestSomethingThatUsesStorer(t *testing.T) {
//
//		// make and configure a mocked store.Storer
//		mockedStorer := &StorerMock{
//			CheckAllBundleContentsAreApprovedFunc: func(ctx context.Context, bundleID string) (bool, error) {
//				panic("mock out the CheckAllBundleContentsAreApproved method")
//			},
//			CheckBundleExistsFunc: func(ctx context.Context, bundleID string) (bool, error) {
//				panic("mock out the CheckBundleExists method")
//			},
//			CheckBundleExistsByTitleFunc: func(ctx context.Context, title string) (bool, error) {
//				panic("mock out the CheckBundleExistsByTitle method")
//			},
//			CheckContentItemExistsByDatasetEditionVersionFunc: func(ctx context.Context, datasetID string, editionID string, versionID int) (bool, error) {
//				panic("mock out the CheckContentItemExistsByDatasetEditionVersion method")
//			},
//			CheckerFunc: func(ctx context.Context, state *healthcheck.CheckState) error {
//				panic("mock out the Checker method")
//			},
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			CreateBundleFunc: func(ctx context.Context, bundle *models.Bundle) error {
//				panic("mock out the CreateBundle method")
//			},
//			CreateBundleEventFunc: func(ctx context.Context, event *models.Event) error {
//				panic("mock out the CreateBundleEvent method")
//			},
//			CreateContentItemFunc: func(ctx context.Context, contentItem *models.ContentItem) error {
//				panic("mock out the CreateContentItem method")
//			},
//			DeleteBundleFunc: func(ctx context.Context, id string) error {
//				panic("mock out the DeleteBundle method")
//			},
//			DeleteContentItemFunc: func(ctx context.Context, contentItemID string) error {
//				panic("mock out the DeleteContentItem method")
//			},
//			GetBundleFunc: func(ctx context.Context, bundleID string) (*models.Bundle, error) {
//				panic("mock out the GetBundle method")
//			},
//			GetContentItemByBundleIDAndContentItemIDFunc: func(ctx context.Context, bundleID string, contentItemID string) (*models.ContentItem, error) {
//				panic("mock out the GetContentItemByBundleIDAndContentItemID method")
//			},
//			ListBundleContentsFunc: func(ctx context.Context, bundleID string, offset int, limit int) ([]*models.ContentItem, int, error) {
//				panic("mock out the ListBundleContents method")
//			},
//			ListBundleContentsWithoutLimitFunc: func(ctx context.Context, bundleID string) ([]*models.ContentItem, int, error) {
//				panic("mock out the ListBundleContentsWithoutLimit method")
//			},
//			ListBundleEventsFunc: func(ctx context.Context, offset int, limit int, bundleID string, after *time.Time, before *time.Time) ([]*models.Event, int, error) {
//				panic("mock out the ListBundleEvents method")
//			},
//			ListBundlesFunc: func(ctx context.Context, offset int, limit int, filtersMoqParam *filters.BundleFilters) ([]*models.Bundle, int, error) {
//				panic("mock out the ListBundles method")
//			},
//			UpdateBundleETagFunc: func(ctx context.Context, bundleID string, email string) (*models.Bundle, error) {
//				panic("mock out the UpdateBundleETag method")
//			},
//		}
//
//		// use mockedStorer in code that requires store.Storer
//		// and then make assertions.
//
//	}
type StorerMock struct {
	// CheckAllBundleContentsAreApprovedFunc mocks the CheckAllBundleContentsAreApproved method.
	CheckAllBundleContentsAreApprovedFunc func(ctx context.Context, bundleID string) (bool, error)

	// CheckBundleExistsFunc mocks the CheckBundleExists method.
	CheckBundleExistsFunc func(ctx context.Context, bundleID string) (bool, error)

	// CheckBundleExistsByTitleFunc mocks the CheckBundleExistsByTitle method.
	CheckBundleExistsByTitleFunc func(ctx context.Context, title string) (bool, error)

	// CheckContentItemExistsByDatasetEditionVersionFunc mocks the CheckContentItemExistsByDatasetEditionVersion method.
	CheckContentItemExistsByDatasetEditionVersionFunc func(ctx context.Context, datasetID string, editionID string, versionID int) (bool, error)

	// CheckerFunc mocks the Checker method.
	CheckerFunc func(ctx context.Context, state *healthcheck.CheckState) error

	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// CreateBundleFunc mocks the CreateBundle method.
	CreateBundleFunc func(ctx context.Context, bundle *models.Bundle) error

	// CreateBundleEventFunc mocks the CreateBundleEvent method.
	CreateBundleEventFunc func(ctx context.Context, event *models.Event) error

	// CreateContentItemFunc mocks the CreateContentItem method.
	CreateContentItemFunc func(ctx context.Context, contentItem *models.ContentItem) error

	// DeleteBundleFunc mocks the DeleteBundle method.
	DeleteBundleFunc func(ctx context.Context, id string) error

	// DeleteContentItemFunc mocks the DeleteContentItem method.
	DeleteContentItemFunc func(ctx context.Context, contentItemID string) error

	// GetBundleFunc mocks the GetBundle method.
	GetBundleFunc func(ctx context.Context, bundleID string) (*models.Bundle, error)

	// GetContentItemByBundleIDAndContentItemIDFunc mocks the GetContentItemByBundleIDAndContentItemID method.
	GetContentItemByBundleIDAndContentItemIDFunc func(ctx context.Context, bundleID string, contentItemID string) (*models.ContentItem, error)

	// ListBundleContentsFunc mocks the ListBundleContents method.
	ListBundleContentsFunc func(ctx context.Context, bundleID string, offset int, limit int) ([]*models.ContentItem, int, error)

	// ListBundleContentsWithoutLimitFunc mocks the ListBundleContentsWithoutLimit method.
	ListBundleContentsWithoutLimitFunc func(ctx context.Context, bundleID string) ([]*models.ContentItem, int, error)

	// ListBundleEventsFunc mocks the ListBundleEvents method.
	ListBundleEventsFunc func(ctx context.Context, offset int, limit int, bundleID string, after *time.Time, before *time.Time) ([]*models.Event, int, error)

	// ListBundlesFunc mocks the ListBundles method.
	ListBundlesFunc func(ctx context.Context, offset int, limit int, filtersMoqParam *filters.BundleFilters) ([]*models.Bundle, int, error)

	// UpdateBundleETagFunc mocks the UpdateBundleETag method.
	UpdateBundleETagFunc func(ctx context.Context, bundleID string, email string) (*models.Bundle, error)

	// calls tracks calls to the methods.
	calls struct {
		// CheckAllBundleContentsAreApproved holds details about calls to the CheckAllBundleContentsAreApproved method.
		CheckAllBundleContentsAreApproved []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
		}
		// CheckBundleExists holds details about calls to the CheckBundleExists method.
		CheckBundleExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
		}
		// CheckBundleExistsByTitle holds details about calls to the CheckBundleExistsByTitle method.
		CheckBundleExistsByTitle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Title is the title argument value.
			Title string
		}
		// CheckContentItemExistsByDatasetEditionVersion holds details about calls to the CheckContentItemExistsByDatasetEditionVersion method.
		CheckContentItemExistsByDatasetEditionVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// VersionID is the versionID argument value.
			VersionID int
		}
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// State is the state argument value.
			State *healthcheck.CheckState
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateBundle holds details about calls to the CreateBundle method.
		CreateBundle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Bundle is the bundle argument value.
			Bundle *models.Bundle
		}
		// CreateBundleEvent holds details about calls to the CreateBundleEvent method.
		CreateBundleEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *models.Event
		}
		// CreateContentItem holds details about calls to the CreateContentItem method.
		CreateContentItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ContentItem is the contentItem argument value.
			ContentItem *models.ContentItem
		}
		// DeleteBundle holds details about calls to the DeleteBundle method.
		DeleteBundle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// DeleteContentItem holds details about calls to the DeleteContentItem method.
		DeleteContentItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ContentItemID is the contentItemID argument value.
			ContentItemID string
		}
		// GetBundle holds details about calls to the GetBundle method.
		GetBundle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
		}
		// GetContentItemByBundleIDAndContentItemID holds details about calls to the GetContentItemByBundleIDAndContentItemID method.
		GetContentItemByBundleIDAndContentItemID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
			// ContentItemID is the contentItemID argument value.
			ContentItemID string
		}
		// ListBundleContents holds details about calls to the ListBundleContents method.
		ListBundleContents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// ListBundleContentsWithoutLimit holds details about calls to the ListBundleContentsWithoutLimit method.
		ListBundleContentsWithoutLimit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
		}
		// ListBundleEvents holds details about calls to the ListBundleEvents method.
		ListBundleEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// BundleID is the bundleID argument value.
			BundleID string
			// After is the after argument value.
			After *time.Time
			// Before is the before argument value.
			Before *time.Time
		}
		// ListBundles holds details about calls to the ListBundles method.
		ListBundles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// FiltersMoqParam is the filtersMoqParam argument value.
			FiltersMoqParam *filters.BundleFilters
		}
		// UpdateBundleETag holds details about calls to the UpdateBundleETag method.
		UpdateBundleETag []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BundleID is the bundleID argument value.
			BundleID string
			// Email is the email argument value.
			Email string
		}
	}
	lockCheckAllBundleContentsAreApproved             sync.RWMutex
	lockCheckBundleExists                             sync.RWMutex
	lockCheckBundleExistsByTitle                      sync.RWMutex
	lockCheckContentItemExistsByDatasetEditionVersion sync.RWMutex
	lockChecker                                       sync.RWMutex
	lockClose                                         sync.RWMutex
	lockCreateBundle                                  sync.RWMutex
	lockCreateBundleEvent                             sync.RWMutex
	lockCreateContentItem                             sync.RWMutex
	lockDeleteBundle                                  sync.RWMutex
	lockDeleteContentItem                             sync.RWMutex
	lockGetBundle                                     sync.RWMutex
	lockGetContentItemByBundleIDAndContentItemID      sync.RWMutex
	lockListBundleContents                            sync.RWMutex
	lockListBundleContentsWithoutLimit                sync.RWMutex
	lockListBundleEvents                              sync.RWMutex
	lockListBundles                                   sync.RWMutex
	lockUpdateBundleETag                              sync.RWMutex
}

// CheckAllBundleContentsAreApproved calls CheckAllBundleContentsAreApprovedFunc.
func (mock *StorerMock) CheckAllBundleContentsAreApproved(ctx context.Context, bundleID string) (bool, error) {
	if mock.CheckAllBundleContentsAreApprovedFunc == nil {
		panic("StorerMock.CheckAllBundleContentsAreApprovedFunc: method is nil but Storer.CheckAllBundleContentsAreApproved was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
	}
	mock.lockCheckAllBundleContentsAreApproved.Lock()
	mock.calls.CheckAllBundleContentsAreApproved = append(mock.calls.CheckAllBundleContentsAreApproved, callInfo)
	mock.lockCheckAllBundleContentsAreApproved.Unlock()
	return mock.CheckAllBundleContentsAreApprovedFunc(ctx, bundleID)
}

// CheckAllBundleContentsAreApprovedCalls gets all the calls that were made to CheckAllBundleContentsAreApproved.
// Check the length with:
//
//	len(mockedStorer.CheckAllBundleContentsAreApprovedCalls())
func (mock *StorerMock) CheckAllBundleContentsAreApprovedCalls() []struct {
	Ctx      context.Context
	BundleID string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
	}
	mock.lockCheckAllBundleContentsAreApproved.RLock()
	calls = mock.calls.CheckAllBundleContentsAreApproved
	mock.lockCheckAllBundleContentsAreApproved.RUnlock()
	return calls
}

// CheckBundleExists calls CheckBundleExistsFunc.
func (mock *StorerMock) CheckBundleExists(ctx context.Context, bundleID string) (bool, error) {
	if mock.CheckBundleExistsFunc == nil {
		panic("StorerMock.CheckBundleExistsFunc: method is nil but Storer.CheckBundleExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
	}
	mock.lockCheckBundleExists.Lock()
	mock.calls.CheckBundleExists = append(mock.calls.CheckBundleExists, callInfo)
	mock.lockCheckBundleExists.Unlock()
	return mock.CheckBundleExistsFunc(ctx, bundleID)
}

// CheckBundleExistsCalls gets all the calls that were made to CheckBundleExists.
// Check the length with:
//
//	len(mockedStorer.CheckBundleExistsCalls())
func (mock *StorerMock) CheckBundleExistsCalls() []struct {
	Ctx      context.Context
	BundleID string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
	}
	mock.lockCheckBundleExists.RLock()
	calls = mock.calls.CheckBundleExists
	mock.lockCheckBundleExists.RUnlock()
	return calls
}

// CheckBundleExistsByTitle calls CheckBundleExistsByTitleFunc.
func (mock *StorerMock) CheckBundleExistsByTitle(ctx context.Context, title string) (bool, error) {
	if mock.CheckBundleExistsByTitleFunc == nil {
		panic("StorerMock.CheckBundleExistsByTitleFunc: method is nil but Storer.CheckBundleExistsByTitle was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Title string
	}{
		Ctx:   ctx,
		Title: title,
	}
	mock.lockCheckBundleExistsByTitle.Lock()
	mock.calls.CheckBundleExistsByTitle = append(mock.calls.CheckBundleExistsByTitle, callInfo)
	mock.lockCheckBundleExistsByTitle.Unlock()
	return mock.CheckBundleExistsByTitleFunc(ctx, title)
}

// CheckBundleExistsByTitleCalls gets all the calls that were made to CheckBundleExistsByTitle.
// Check the length with:
//
//	len(mockedStorer.CheckBundleExistsByTitleCalls())
func (mock *StorerMock) CheckBundleExistsByTitleCalls() []struct {
	Ctx   context.Context
	Title string
} {
	var calls []struct {
		Ctx   context.Context
		Title string
	}
	mock.lockCheckBundleExistsByTitle.RLock()
	calls = mock.calls.CheckBundleExistsByTitle
	mock.lockCheckBundleExistsByTitle.RUnlock()
	return calls
}

// CheckContentItemExistsByDatasetEditionVersion calls CheckContentItemExistsByDatasetEditionVersionFunc.
func (mock *StorerMock) CheckContentItemExistsByDatasetEditionVersion(ctx context.Context, datasetID string, editionID string, versionID int) (bool, error) {
	if mock.CheckContentItemExistsByDatasetEditionVersionFunc == nil {
		panic("StorerMock.CheckContentItemExistsByDatasetEditionVersionFunc: method is nil but Storer.CheckContentItemExistsByDatasetEditionVersion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		VersionID int
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
		VersionID: versionID,
	}
	mock.lockCheckContentItemExistsByDatasetEditionVersion.Lock()
	mock.calls.CheckContentItemExistsByDatasetEditionVersion = append(mock.calls.CheckContentItemExistsByDatasetEditionVersion, callInfo)
	mock.lockCheckContentItemExistsByDatasetEditionVersion.Unlock()
	return mock.CheckContentItemExistsByDatasetEditionVersionFunc(ctx, datasetID, editionID, versionID)
}

// CheckContentItemExistsByDatasetEditionVersionCalls gets all the calls that were made to CheckContentItemExistsByDatasetEditionVersion.
// Check the length with:
//
//	len(mockedStorer.CheckContentItemExistsByDatasetEditionVersionCalls())
func (mock *StorerMock) CheckContentItemExistsByDatasetEditionVersionCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
	VersionID int
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		VersionID int
	}
	mock.lockCheckContentItemExistsByDatasetEditionVersion.RLock()
	calls = mock.calls.CheckContentItemExistsByDatasetEditionVersion
	mock.lockCheckContentItemExistsByDatasetEditionVersion.RUnlock()
	return calls
}

// Checker calls CheckerFunc.
func (mock *StorerMock) Checker(ctx context.Context, state *healthcheck.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("StorerMock.CheckerFunc: method is nil but Storer.Checker was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}{
		Ctx:   ctx,
		State: state,
	}
	mock.lockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	mock.lockChecker.Unlock()
	return mock.CheckerFunc(ctx, state)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//
//	len(mockedStorer.CheckerCalls())
func (mock *StorerMock) CheckerCalls() []struct {
	Ctx   context.Context
	State *healthcheck.CheckState
} {
	var calls []struct {
		Ctx   context.Context
		State *healthcheck.CheckState
	}
	mock.lockChecker.RLock()
	calls = mock.calls.Checker
	mock.lockChecker.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *StorerMock) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("StorerMock.CloseFunc: method is nil but Storer.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedStorer.CloseCalls())
func (mock *StorerMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CreateBundle calls CreateBundleFunc.
func (mock *StorerMock) CreateBundle(ctx context.Context, bundle *models.Bundle) error {
	if mock.CreateBundleFunc == nil {
		panic("StorerMock.CreateBundleFunc: method is nil but Storer.CreateBundle was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Bundle *models.Bundle
	}{
		Ctx:    ctx,
		Bundle: bundle,
	}
	mock.lockCreateBundle.Lock()
	mock.calls.CreateBundle = append(mock.calls.CreateBundle, callInfo)
	mock.lockCreateBundle.Unlock()
	return mock.CreateBundleFunc(ctx, bundle)
}

// CreateBundleCalls gets all the calls that were made to CreateBundle.
// Check the length with:
//
//	len(mockedStorer.CreateBundleCalls())
func (mock *StorerMock) CreateBundleCalls() []struct {
	Ctx    context.Context
	Bundle *models.Bundle
} {
	var calls []struct {
		Ctx    context.Context
		Bundle *models.Bundle
	}
	mock.lockCreateBundle.RLock()
	calls = mock.calls.CreateBundle
	mock.lockCreateBundle.RUnlock()
	return calls
}

// CreateBundleEvent calls CreateBundleEventFunc.
func (mock *StorerMock) CreateBundleEvent(ctx context.Context, event *models.Event) error {
	if mock.CreateBundleEventFunc == nil {
		panic("StorerMock.CreateBundleEventFunc: method is nil but Storer.CreateBundleEvent was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *models.Event
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockCreateBundleEvent.Lock()
	mock.calls.CreateBundleEvent = append(mock.calls.CreateBundleEvent, callInfo)
	mock.lockCreateBundleEvent.Unlock()
	return mock.CreateBundleEventFunc(ctx, event)
}

// CreateBundleEventCalls gets all the calls that were made to CreateBundleEvent.
// Check the length with:
//
//	len(mockedStorer.CreateBundleEventCalls())
func (mock *StorerMock) CreateBundleEventCalls() []struct {
	Ctx   context.Context
	Event *models.Event
} {
	var calls []struct {
		Ctx   context.Context
		Event *models.Event
	}
	mock.lockCreateBundleEvent.RLock()
	calls = mock.calls.CreateBundleEvent
	mock.lockCreateBundleEvent.RUnlock()
	return calls
}

// CreateContentItem calls CreateContentItemFunc.
func (mock *StorerMock) CreateContentItem(ctx context.Context, contentItem *models.ContentItem) error {
	if mock.CreateContentItemFunc == nil {
		panic("StorerMock.CreateContentItemFunc: method is nil but Storer.CreateContentItem was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ContentItem *models.ContentItem
	}{
		Ctx:         ctx,
		ContentItem: contentItem,
	}
	mock.lockCreateContentItem.Lock()
	mock.calls.CreateContentItem = append(mock.calls.CreateContentItem, callInfo)
	mock.lockCreateContentItem.Unlock()
	return mock.CreateContentItemFunc(ctx, contentItem)
}

// CreateContentItemCalls gets all the calls that were made to CreateContentItem.
// Check the length with:
//
//	len(mockedStorer.CreateContentItemCalls())
func (mock *StorerMock) CreateContentItemCalls() []struct {
	Ctx         context.Context
	ContentItem *models.ContentItem
} {
	var calls []struct {
		Ctx         context.Context
		ContentItem *models.ContentItem
	}
	mock.lockCreateContentItem.RLock()
	calls = mock.calls.CreateContentItem
	mock.lockCreateContentItem.RUnlock()
	return calls
}

// DeleteBundle calls DeleteBundleFunc.
func (mock *StorerMock) DeleteBundle(ctx context.Context, id string) error {
	if mock.DeleteBundleFunc == nil {
		panic("StorerMock.DeleteBundleFunc: method is nil but Storer.DeleteBundle was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteBundle.Lock()
	mock.calls.DeleteBundle = append(mock.calls.DeleteBundle, callInfo)
	mock.lockDeleteBundle.Unlock()
	return mock.DeleteBundleFunc(ctx, id)
}

// DeleteBundleCalls gets all the calls that were made to DeleteBundle.
// Check the length with:
//
//	len(mockedStorer.DeleteBundleCalls())
func (mock *StorerMock) DeleteBundleCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteBundle.RLock()
	calls = mock.calls.DeleteBundle
	mock.lockDeleteBundle.RUnlock()
	return calls
}

// DeleteContentItem calls DeleteContentItemFunc.
func (mock *StorerMock) DeleteContentItem(ctx context.Context, contentItemID string) error {
	if mock.DeleteContentItemFunc == nil {
		panic("StorerMock.DeleteContentItemFunc: method is nil but Storer.DeleteContentItem was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ContentItemID string
	}{
		Ctx:           ctx,
		ContentItemID: contentItemID,
	}
	mock.lockDeleteContentItem.Lock()
	mock.calls.DeleteContentItem = append(mock.calls.DeleteContentItem, callInfo)
	mock.lockDeleteContentItem.Unlock()
	return mock.DeleteContentItemFunc(ctx, contentItemID)
}

// DeleteContentItemCalls gets all the calls that were made to DeleteContentItem.
// Check the length with:
//
//	len(mockedStorer.DeleteContentItemCalls())
func (mock *StorerMock) DeleteContentItemCalls() []struct {
	Ctx           context.Context
	ContentItemID string
} {
	var calls []struct {
		Ctx           context.Context
		ContentItemID string
	}
	mock.lockDeleteContentItem.RLock()
	calls = mock.calls.DeleteContentItem
	mock.lockDeleteContentItem.RUnlock()
	return calls
}

// GetBundle calls GetBundleFunc.
func (mock *StorerMock) GetBundle(ctx context.Context, bundleID string) (*models.Bundle, error) {
	if mock.GetBundleFunc == nil {
		panic("StorerMock.GetBundleFunc: method is nil but Storer.GetBundle was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
	}
	mock.lockGetBundle.Lock()
	mock.calls.GetBundle = append(mock.calls.GetBundle, callInfo)
	mock.lockGetBundle.Unlock()
	return mock.GetBundleFunc(ctx, bundleID)
}

// GetBundleCalls gets all the calls that were made to GetBundle.
// Check the length with:
//
//	len(mockedStorer.GetBundleCalls())
func (mock *StorerMock) GetBundleCalls() []struct {
	Ctx      context.Context
	BundleID string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
	}
	mock.lockGetBundle.RLock()
	calls = mock.calls.GetBundle
	mock.lockGetBundle.RUnlock()
	return calls
}

// GetContentItemByBundleIDAndContentItemID calls GetContentItemByBundleIDAndContentItemIDFunc.
func (mock *StorerMock) GetContentItemByBundleIDAndContentItemID(ctx context.Context, bundleID string, contentItemID string) (*models.ContentItem, error) {
	if mock.GetContentItemByBundleIDAndContentItemIDFunc == nil {
		panic("StorerMock.GetContentItemByBundleIDAndContentItemIDFunc: method is nil but Storer.GetContentItemByBundleIDAndContentItemID was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		BundleID      string
		ContentItemID string
	}{
		Ctx:           ctx,
		BundleID:      bundleID,
		ContentItemID: contentItemID,
	}
	mock.lockGetContentItemByBundleIDAndContentItemID.Lock()
	mock.calls.GetContentItemByBundleIDAndContentItemID = append(mock.calls.GetContentItemByBundleIDAndContentItemID, callInfo)
	mock.lockGetContentItemByBundleIDAndContentItemID.Unlock()
	return mock.GetContentItemByBundleIDAndContentItemIDFunc(ctx, bundleID, contentItemID)
}

// GetContentItemByBundleIDAndContentItemIDCalls gets all the calls that were made to GetContentItemByBundleIDAndContentItemID.
// Check the length with:
//
//	len(mockedStorer.GetContentItemByBundleIDAndContentItemIDCalls())
func (mock *StorerMock) GetContentItemByBundleIDAndContentItemIDCalls() []struct {
	Ctx           context.Context
	BundleID      string
	ContentItemID string
} {
	var calls []struct {
		Ctx           context.Context
		BundleID      string
		ContentItemID string
	}
	mock.lockGetContentItemByBundleIDAndContentItemID.RLock()
	calls = mock.calls.GetContentItemByBundleIDAndContentItemID
	mock.lockGetContentItemByBundleIDAndContentItemID.RUnlock()
	return calls
}

// ListBundleContents calls ListBundleContentsFunc.
func (mock *StorerMock) ListBundleContents(ctx context.Context, bundleID string, offset int, limit int) ([]*models.ContentItem, int, error) {
	if mock.ListBundleContentsFunc == nil {
		panic("StorerMock.ListBundleContentsFunc: method is nil but Storer.ListBundleContents was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
		Offset   int
		Limit    int
	}{
		Ctx:      ctx,
		BundleID: bundleID,
		Offset:   offset,
		Limit:    limit,
	}
	mock.lockListBundleContents.Lock()
	mock.calls.ListBundleContents = append(mock.calls.ListBundleContents, callInfo)
	mock.lockListBundleContents.Unlock()
	return mock.ListBundleContentsFunc(ctx, bundleID, offset, limit)
}

// ListBundleContentsCalls gets all the calls that were made to ListBundleContents.
// Check the length with:
//
//	len(mockedStorer.ListBundleContentsCalls())
func (mock *StorerMock) ListBundleContentsCalls() []struct {
	Ctx      context.Context
	BundleID string
	Offset   int
	Limit    int
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
		Offset   int
		Limit    int
	}
	mock.lockListBundleContents.RLock()
	calls = mock.calls.ListBundleContents
	mock.lockListBundleContents.RUnlock()
	return calls
}

// ListBundleContentsWithoutLimit calls ListBundleContentsWithoutLimitFunc.
func (mock *StorerMock) ListBundleContentsWithoutLimit(ctx context.Context, bundleID string) ([]*models.ContentItem, int, error) {
	if mock.ListBundleContentsWithoutLimitFunc == nil {
		panic("StorerMock.ListBundleContentsWithoutLimitFunc: method is nil but Storer.ListBundleContentsWithoutLimit was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
	}
	mock.lockListBundleContentsWithoutLimit.Lock()
	mock.calls.ListBundleContentsWithoutLimit = append(mock.calls.ListBundleContentsWithoutLimit, callInfo)
	mock.lockListBundleContentsWithoutLimit.Unlock()
	return mock.ListBundleContentsWithoutLimitFunc(ctx, bundleID)
}

// ListBundleContentsWithoutLimitCalls gets all the calls that were made to ListBundleContentsWithoutLimit.
// Check the length with:
//
//	len(mockedStorer.ListBundleContentsWithoutLimitCalls())
func (mock *StorerMock) ListBundleContentsWithoutLimitCalls() []struct {
	Ctx      context.Context
	BundleID string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
	}
	mock.lockListBundleContentsWithoutLimit.RLock()
	calls = mock.calls.ListBundleContentsWithoutLimit
	mock.lockListBundleContentsWithoutLimit.RUnlock()
	return calls
}

// ListBundleEvents calls ListBundleEventsFunc.
func (mock *StorerMock) ListBundleEvents(ctx context.Context, offset int, limit int, bundleID string, after *time.Time, before *time.Time) ([]*models.Event, int, error) {
	if mock.ListBundleEventsFunc == nil {
		panic("StorerMock.ListBundleEventsFunc: method is nil but Storer.ListBundleEvents was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Offset   int
		Limit    int
		BundleID string
		After    *time.Time
		Before   *time.Time
	}{
		Ctx:      ctx,
		Offset:   offset,
		Limit:    limit,
		BundleID: bundleID,
		After:    after,
		Before:   before,
	}
	mock.lockListBundleEvents.Lock()
	mock.calls.ListBundleEvents = append(mock.calls.ListBundleEvents, callInfo)
	mock.lockListBundleEvents.Unlock()
	return mock.ListBundleEventsFunc(ctx, offset, limit, bundleID, after, before)
}

// ListBundleEventsCalls gets all the calls that were made to ListBundleEvents.
// Check the length with:
//
//	len(mockedStorer.ListBundleEventsCalls())
func (mock *StorerMock) ListBundleEventsCalls() []struct {
	Ctx      context.Context
	Offset   int
	Limit    int
	BundleID string
	After    *time.Time
	Before   *time.Time
} {
	var calls []struct {
		Ctx      context.Context
		Offset   int
		Limit    int
		BundleID string
		After    *time.Time
		Before   *time.Time
	}
	mock.lockListBundleEvents.RLock()
	calls = mock.calls.ListBundleEvents
	mock.lockListBundleEvents.RUnlock()
	return calls
}

// ListBundles calls ListBundlesFunc.
func (mock *StorerMock) ListBundles(ctx context.Context, offset int, limit int, filtersMoqParam *filters.BundleFilters) ([]*models.Bundle, int, error) {
	if mock.ListBundlesFunc == nil {
		panic("StorerMock.ListBundlesFunc: method is nil but Storer.ListBundles was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Offset          int
		Limit           int
		FiltersMoqParam *filters.BundleFilters
	}{
		Ctx:             ctx,
		Offset:          offset,
		Limit:           limit,
		FiltersMoqParam: filtersMoqParam,
	}
	mock.lockListBundles.Lock()
	mock.calls.ListBundles = append(mock.calls.ListBundles, callInfo)
	mock.lockListBundles.Unlock()
	return mock.ListBundlesFunc(ctx, offset, limit, filtersMoqParam)
}

// ListBundlesCalls gets all the calls that were made to ListBundles.
// Check the length with:
//
//	len(mockedStorer.ListBundlesCalls())
func (mock *StorerMock) ListBundlesCalls() []struct {
	Ctx             context.Context
	Offset          int
	Limit           int
	FiltersMoqParam *filters.BundleFilters
} {
	var calls []struct {
		Ctx             context.Context
		Offset          int
		Limit           int
		FiltersMoqParam *filters.BundleFilters
	}
	mock.lockListBundles.RLock()
	calls = mock.calls.ListBundles
	mock.lockListBundles.RUnlock()
	return calls
}

// UpdateBundleETag calls UpdateBundleETagFunc.
func (mock *StorerMock) UpdateBundleETag(ctx context.Context, bundleID string, email string) (*models.Bundle, error) {
	if mock.UpdateBundleETagFunc == nil {
		panic("StorerMock.UpdateBundleETagFunc: method is nil but Storer.UpdateBundleETag was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		BundleID string
		Email    string
	}{
		Ctx:      ctx,
		BundleID: bundleID,
		Email:    email,
	}
	mock.lockUpdateBundleETag.Lock()
	mock.calls.UpdateBundleETag = append(mock.calls.UpdateBundleETag, callInfo)
	mock.lockUpdateBundleETag.Unlock()
	return mock.UpdateBundleETagFunc(ctx, bundleID, email)
}

// UpdateBundleETagCalls gets all the calls that were made to UpdateBundleETag.
// Check the length with:
//
//	len(mockedStorer.UpdateBundleETagCalls())
func (mock *StorerMock) UpdateBundleETagCalls() []struct {
	Ctx      context.Context
	BundleID string
	Email    string
} {
	var calls []struct {
		Ctx      context.Context
		BundleID string
		Email    string
	}
	mock.lockUpdateBundleETag.RLock()
	calls = mock.calls.UpdateBundleETag
	mock.lockUpdateBundleETag.RUnlock()
	return calls
}
